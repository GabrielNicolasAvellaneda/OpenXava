<?xml version="1.0" encoding="ISO-8859-1"?>
#declare import="org.openxava.component.MetaComponent"#
#declare import="org.openxava.model.meta.*"#
#declare import="org.openxava.mapping.*"#
#declare import="org.openxava.util.Strings"#
#declare import="org.openxava.util.XavaException"#

<!-- Generated by OpenXava: #(new Date())# -->
# 
String packageName = properties.getProperty("arg3");
String componentName = properties.getProperty("arg4");
String aggregateName = properties.getProperty("arg5");
MetaComponent component = MetaComponent.get(componentName);

String name=null;
IMetaModel metaModel=null;
if (aggregateName == null) {
	name=componentName;	
	metaModel = (IMetaModel) component.getMetaEntity();
}
else {
	name=aggregateName;	
	metaModel =  (IMetaEjb)component.getMetaAggregate(aggregateName);
}
ModelMapping mapping = metaModel.getMapping();
#

<!DOCTYPE hibernate-mapping SYSTEM "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="#(packageName)#">

  <class 
  	name="#(name)#"
  	table="#(mapping.getTable())#">
  	
# 
Collection keyMembers = metaModel.getMetaMembersKey();
Collection keyProperties = metaModel.getMetaPropertiesKey(); 
if (keyMembers.size() == 0) {
	throw new XavaException("model_without_key_error", name);
}
else if (keyProperties.size() == 1 &&  keyMembers.size() == 1) {
		MetaProperty key = (MetaProperty) keyProperties.iterator().next();
		PropertyMapping pMapping = key.getMapping();
		String propertyName = key.getName();	
		String generator = key.isHidden() && !key.hasCalculatorDefaultValueOnCreate()?"native":"assigned";
		String type = pMapping.getCmpType().isArray()?"":"type='" + pMapping.getCmpTypeName() + "'";
# 	
		<id name="#(propertyName)#" column="#(pMapping.getColumn())#" access="field" #(type)#>
			<generator class="#(generator)#"/>
		</id>
# 
}
else {
# 
		<composite-id>
# 
	for (Iterator it = keyMembers.iterator(); it.hasNext();) {
    	MetaMember key = (MetaMember) it.next();
    	if (key instanceof MetaProperty) {
			PropertyMapping pMapping = ((MetaProperty) key).getMapping();
			String propertyName = key.getName();			
			String type = pMapping.getCmpType().isArray()?"":"type='" + pMapping.getCmpTypeName() + "'";			
# 	
			<key-property name="#(propertyName)#" column="#(pMapping.getColumn())#" access="field" #(type)#/>
# 
		}
		if (key instanceof MetaReference) {
			if (mapping.isReferenceOverlappingWithSomeProperty(key.getName())) {
# 
			<!-- Reference: #(key.getName())# : Overlapped references still not supported -->
# 			
			}
			else {
				ReferenceMapping pMapping = mapping.getReferenceMapping(key.getName());
				String referenceName = key.getName();	
				String className = ((MetaReference) key).getMetaModelReferenced().getPOJOClassName();		
# 	
			<key-many-to-one name="#(referenceName)#" class="#(className)#"> 
# 
				for (Iterator itC = pMapping.getColumns().iterator(); itC.hasNext();) {
					String col = (String) itC.next();				
# 			
				<column name="#(col)#"/>
# 
				}			
# 						
			</key-many-to-one>
# 	
			}
 		} 		
 	}	
#  	
		</composite-id>
# 		
}
	Collection properties = metaModel.getMetaPropertiesPersistents();
	for (Iterator it = properties.iterator(); it.hasNext();) {
		MetaProperty prop = (MetaProperty) it.next();
		PropertyMapping pMapping = prop.getMapping();
		String propertyName = prop.getName();			
		if (!prop.isKey()) {
			if (pMapping.hasMultipleConverter()) {
# 
		<!--  Mapping of "#(propertyName)#" : multiple columns mapping still not supported -->
# 			
			}
			else {
				String type = pMapping.getCmpType().isArray()?"":"type='" + pMapping.getCmpTypeName() + "'";
# 	
		<property name="#(propertyName)#" column="#(pMapping.getColumn())#" access="field" #(type)#/>
# 
			} 	
		} 
	}
 
Iterator itReferences = metaModel.getMetaReferences().iterator();	
while (itReferences.hasNext()) {	
	MetaReference reference = (MetaReference) itReferences.next();
	if (reference.isKey()) continue;
	String referenceName = Strings.firstUpper(reference.getName());	
	if (reference.getMetaModelReferenced() instanceof MetaAggregateBean) {	
		for (Iterator itAggregateProperties = reference.getMetaModelReferenced().getMetaPropertiesPersistents().iterator(); itAggregateProperties.hasNext();) {	
			MetaProperty property = (MetaProperty) itAggregateProperties.next();
			String propertyName = "_" + referenceName + "_" + property.getName();
			String column = mapping.getColumn(reference.getName() + "_" + property.getName()); 
			String type = property.getMapping().getCmpType().isArray()?"":"type='" + property.getMapping().getCmpTypeName() + "'";			
# 
		<property name="#(propertyName)#" column="#(column)#" access="field" #(type)#/>
# 
		} 
		for (Iterator itAggregateReferences = reference.getMetaModelReferenced().getMetaReferences().iterator(); itAggregateReferences.hasNext();) {	
			MetaReference ref = (MetaReference) itAggregateReferences.next();
			String refName = reference.getName() + "_" + ref.getName();
			Collection columns = mapping.getReferenceMapping(reference.getName() + "_" + ref.getName()).getColumns();   
  			if (columns.size() == 1) {	
				String column = (String) columns.iterator().next();
# 
		<many-to-one name="#(refName)#" column="#(column)#" class="#(ref.getMetaModelReferenced().getPOJOClassName())#" not-found="ignore"/>
# 
			}
			else { 
# 
		<many-to-one name="#(refName)#" class="#(ref.getMetaModelReferenced().getPOJOClassName())#" not-found="ignore"> 
# 
			for (Iterator itC = columns.iterator(); itC.hasNext();) {
				String col = (String) itC.next();
# 
			<column name="#(col)#" />
# 
			}
# 
		</many-to-one>
# 
			}         
		}
	} 
	else { // reference to entity or persistent aggregate 
		Collection columns = mapping.getReferenceMapping(reference.getName()).getColumns();   
  		if (columns.size() == 1) {	
			String column = (String) columns.iterator().next();
# 
		<many-to-one name="#(reference.getName())#" column="#(column)#" class="#(reference.getMetaModelReferenced().getPOJOClassName())#" not-found="ignore"/>
# 
		}
		else { 
			if (mapping.isReferenceOverlappingWithSomeProperty(reference.getName())) {
# 			
			<!-- Reference: #(reference.getName())# Overlapped references still not supported -->
# 
			}
			else {
# 
		<many-to-one name="#(reference.getName())#" class="#(reference.getMetaModelReferenced().getPOJOClassName())#" not-found="ignore"> 
# 
			for (Iterator itC = columns.iterator(); itC.hasNext();) {
				String col = (String) itC.next();
# 
			<column name="#(col)#"/>
# 			
			}
# 
		</many-to-one>
# 
			}
		}
	}
} 
 
Iterator itCollections = metaModel.getMetaCollections().iterator();	
while (itCollections.hasNext()) {	
	MetaCollection col = (MetaCollection) itCollections.next();
	if (col.hasCalculator() || col.hasCondition()) {
		continue;
	}
	boolean isAggregate = col.getMetaReference().getMetaModelReferenced() instanceof MetaAggregate;
	String cascadeDelete = isAggregate?"cascade='delete'":"";
	String roleName = col.getMetaReference().getRole();	 
	Collection columns = col.getMetaReference().getMetaModelReferenced().getMapping().getReferenceMapping(roleName).getColumns();
	Collection cKeys = col.getMetaReference().getMetaModelReferenced().getAllKeyPropertiesNames();
	String nKeys = Strings.toString(cKeys);          		
	if (columns.size() == 1) {	
		String column = (String) columns.iterator().next();
#  
		<set name="#(col.getName())#" order-by="#(nKeys)#" #(cascadeDelete)#>
			<key column="#(column)#"/>
			<one-to-many class="#(col.getMetaReference().getMetaModelReferenced().getName())#"/>
		</set>	
# 
	}	
	else { 
# 
		<set name="#(col.getName())#" order-by="#(nKeys)#" #(cascadeDelete)#>
			<key>
# 
		Iterator itCol = columns.iterator();	
		while (itCol.hasNext()) {	
			String column = (String) itCol.next();
# 			
				<column name="#(column)#"/>
# 			
		}	
# 
			</key>	
			<one-to-many class="#(col.getMetaReference().getMetaModelReferenced().getName())#"/>
		</set>	
# 
	}

}

# 	
  </class>

</hibernate-mapping>

