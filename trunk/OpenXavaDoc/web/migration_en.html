<h2>Migration from OpenXava 1.2 to OpenXava 1.2.1</h2>

<h4>Hibernate generation</h4>
Now when the EJB code generation is done, the hibernate code generation is
executed too (although the hibernate version still does not work at 100%).<br>
Although you use only EJB version, you have to make this little adaptation in your project:
<ul>
<li> Create the folder <code>build/hibernate</code> in your project, and make it a source code folder.
<li> Create the folder <code>hibernate</code> in your project, and make it a source code folder.
<li> Create the file <code>hibernate.cfg.xml</code> inside <code>hibernate</code> folder.
</ul>
The <code>hibernate.cfg.xml</code> have to be:
<pre>
&lt;!DOCTYPE hibernate-configuration PUBLIC
   "-//Hibernate/Hibernate Configuration DTD//EN"
   "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;
  &lt;hibernate-configuration&gt;
   &lt;session-factory&gt;
       &lt;property name="hibernate.connection.datasource"&gt;@datasource.prefix@/@datasource@&lt;/property&gt;
       &lt;property name="hibernate.dialect"&gt;@hibernate.dialect@&lt;/property&gt;
       &lt;property name="hibernate.show_sql"&gt;false&lt;/property&gt;
   &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</pre>
In addition you have to include the <code>hibernate.dialect</code> property in your configuration files:
<pre>
hibernate.dialect=org.hibernate.dialect.HSQLDialect
</pre>

<h2>Migration from OpenXava 1.1 to OpenXava 1.2</h2>

<h4>Generated code</h4>
<p>
Now EJB remote interface has the suffix <i>Remote</i>, and the business interface
generated for each component (for example <code>ICustomer</code>) has no all methods of
the remote interface.<br>
This is for allowing to the future version 2 of OpenXava work with EJB and
Hibernate in the same project and at same time.<br>
In order to adapt you code to this, you must:
<ul>
<li>Delete all generated code
<li>Regenerate all EJB code
<li>Build all
<li>Search and correct all syntax error
</ul>
For correct syntax error you can change code in this way:
<pre>
<b>Customer</b> customer = CustomerUtil.getHome().findByName("PEPE");
String name = customer.getName();
</pre>
By this:
<pre>
<b>ICustomer</b> customer = CustomerUtil.getHome().findByName("PEPE");
String name = customer.getName();
</pre>
If you use specific EJB methods then you need cast to remote interface:
<pre>
<b>Customer</b> customer = CustomerUtil.getHome().findByName("PEPE");
CustomerKey key = customer.getPrimaryKey();
</pre>
By this:
<pre>
<b>CustomerRemote</b> customer = CustomerUtil.getHome().findByName("PEPE");
CustomerKey key = customer.getPrimaryKey();
</pre>
That is, change <code>Customer</code> by <code>ICustomer</code> when possible, 
if not possible change <code>Customer</code> by <code>CustomerRemote</code>.
</p>

<h4>JUnit tests</h4>
<ul>
<li> On deleting an object in a CRUD OpenXava now shows a javascript windows 
	to confirm, instead	of changing to another controller. Hence in your tests
	in order to remove an object from CRUD module you only need use execute("CRUD.delete"). 
	In this case 'yes' is assumed as confirmation answer.
</ul>

<h4>Others</h4>
<ul>
<li> Change the name of packages-ejb.properties in gen-src-xava to packages.properties
		(or you can simply remove packages-ejb.properties and regenerate code).
</li>
</ul>

<h2>Migration from OpenXava 1.0 to OpenXava 1.1</h2>

<h4>APIs</h4>
<ul>
<li>MetaView.getMetaViewCollection now is MetaView.getMetaCollectionView
<li>MetaView.getMetaViewReference now is MetaView.getMetaReferenceView
</ul>


<h4>JUnit tests</h4>
<ul>
<li> Message 'Object deleted successfully' is change by 
	'{0} deleted successfully'. Hence it's required to
	change the asserts of this messages.
</ul>