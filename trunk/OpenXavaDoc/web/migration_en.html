<h2>Migration from OpenXava 2.1 to OpenXava 2.1.3</h2>
<h4>JUnit test and key without value parsed as zero</h4>
Since 2.1.3 if a key property of type int, long or short has no value
in the view when it is parsed is parsed with null (without value), and
not as zero. This has no effect in final user, but possibly you need to
modify some JUnit test. For example if you have in a test case:<br>
<br>
<pre>public void testSomething() throws Exception {<br>  assertValue("number", "");<br>  execute("MyControllers.myAction"); // This does not change number value<br>  assertValue("number", "0"); // because OX parse empty string as 0 (until 2.1.2)<br>  ...<br>}<br></pre>
You now have to write in this way:<br>
<pre>public void testSomething() throws Exception {<br>  assertValue("number", "");<br>  execute("MyControllers.myAction"); // This does not change number value<br>  assertValue("number", ""); // because now (since 2.1.3) OX parse empty string as null<br>  ...<br>}<br></pre>
<h2>Migration from OpenXava 2.0.4 to OpenXava 2.1</h2>
<h4>WebSphere projects</h4>
If you deploy your projects in WebSphere you need to do the next little
changes:<br>
First, in the file hibernate/hibernate.cfg.xml of you project add the
next blue marked code:<br>
<pre>&lt;session-factory&gt;</pre>
<pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;property name="hibernate.connection.datasource"&gt;@datasource.prefix@/@datasource@&lt;/property&gt;</pre>
<pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;property name="hibernate.dialect"&gt;@hibernate.dialect@&lt;/property&gt;</pre>
<pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;property name="hibernate.jdbc.use_get_generated_keys"&gt;false&lt;/property&gt;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </pre>
<pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;property name="hibernate.show_sql"&gt;false&lt;/property&gt;</pre>
<pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </pre>
<pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span
 style="color: rgb(51, 51, 255); font-weight: bold;">@hibernate.properties@</span></pre>
<pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </pre>
<pre>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </pre>
<pre>&lt;/session-factory&gt;</pre>
Second,&nbsp;in your configuration file for websphere (for example
websphere-as400.properties) you have to add:<br>
<pre>hibernate.properties=&lt;property name="hibernate.transaction.manager_lookup_class"&gt;\n\</pre>
<pre>\t\t\torg.hibernate.transaction.WebSphereTransactionManagerLookup\n\</pre>
<pre>\t\t&lt;/property&gt;\n\</pre>
<pre>\t\t&lt;property name="transaction.factory_class"&gt;\n\</pre>
<pre>\t\t\torg.hibernate.transaction.JTATransactionFactory\n\</pre>
<pre>\t\t&lt;/property&gt;</pre>
<h4>Other changes that requires some migration</h4>
<ul>
  <li> wtpBuild ant target is dropped from OX; you can use 'rebuild'
ant target instead. Calling automatically to an ant target from Eclipse
Builder is slow, therefore maybe
you prefer to call manually to 'rebuild' ant target on demmand (when
the XML code of your
OX application is changed). </li>
</ul>
<h2>Migration from OpenXava 2.0.3 to OpenXava 2.0.4</h2>
<h4>Parse of numeric values</h4>
Now data values of type Number (Integer, BigDecimal, Short, etc) and
Boolean (not boolean) are parsed as null if in the User Interface are
in blank.
Before numeric blank field was parsed as 0.
This change does not produce big incompatibility problems because
default-converters.xml
defines the real conversion before to store in database (the real
important matter).
That is, this change affects only displaying. You incompatibility
issues maybe the next one:
<ul>
  <li> The user interface application will display clear fields instead
of 0, when the form is reset</li>
  <li> In junit test maybe you receive a blank when before it was a 0</li>
  <li> If you use View.getValue() for a Number it can be null</li>
</ul>
<h4>API changes</h4>
<ul>
  <li><code>Dates.clonWithoutTime()</code> is renamed to <code>Dates.cloneWithoutTime()</code></li>
</ul>
<h2>Migration from OpenXava 2.0.2 to OpenXava 2.0.3</h2>
<h4>No events on-change when searching are thrown</h4>
OpenXava Reference Guide (in the section 7.5) says that
CRUD.searchByViewKey
does not throw any on-change event, and CRUD.searchExecutingOnChange
throw
all on-change events. But because of a bug in ox2.0.2 (and previous)
the CRUD.searchByViewKey
threw on-change events of keys in the references, and
CRUD.searchExecutingOnChange does
not threw CRUD.searchExecutingOnChange of key in the references.
This issue is fixed, therefore if your code rely in this erroneus
behaviour you will
need to adapt it.
<h4>Setting value for references (in combos) with compose key in JUnit
tests</h4>
Setting value for references (in combos) with compose key in JUnit
tests must
be done using POJOs, now the use of EJB2 primary key is not supported.<br>
See documentation in <i>Migration from OpenXava 1.2.1 to OpenXava 2</i>
below.
<h2>Migration from OpenXava 2.0.1 to OpenXava 2.0.2</h2>
Action <code>Collection.hiddenDetail</code> has been renamed to <code>Collection.hideDetail</code>
in <i>controllers.xml</i>. You have to rename the action inside your
junit tests.
<h2>Migration from OpenXava 2.0 to OpenXava 2.0.1</h2>
No issues
<h2>Migration from OpenXava 1.2.1 to OpenXava 2</h2>
<h4>Setting value for references (in combos) with compose key in JUnit
tests</h4>
So far, to set the value to a reference displayed as <code>description-list</code>
(as combo), and mapped in database using multiple columns, you write:
<pre>DrivingLicenceKey key = new DrivingLicenceKey();<br>key.setType("C ");<br>key.setLevel(1);<br>setValue("drivingLicence.KEY", key.toString());		<br></pre>
But, if you uses a pure POJOs version, without Key classes, you have to
write:
<pre>DrivingLicence key = new DrivingLicence();<br>key.setType("C ");<br>key.setLevel(1);<br>setValue("drivingLicence.KEY", key.toString());		<br></pre>
It's better to use the last way, because it's valid for POJOs and EJBs.
<h4>Hibernate: References with not null columns as foreign key</h4>
In EJB version if you have a reference to another entity that has
primitive
types as key, the code is generated in a way that no null is saved to
database,
even if you assign null to your reference.<br>
In hibernate version if you assign null to the reference, null values
are saved
in database.<br>
Of course, the behaviour of hibernate version is more correct, but you
can in
hibernate avoid null in database just using a converter in the
reference mapping
(see section 6.3 of Reference Guide).<br>
That is, maybe you need to add some converters to your references in
order
to migrate your application from EJB2 to Hibernate.<br>
<h4>Changing the active section</h4>
<code>xava_activeSection</code> is not longer used for changing the
active section.
Now if you want to change the active section you must to call to method
<code>setActiveSection</code>
of the desired view (<code>org.openxava.view.View</code>).
<h4>IAggragetOidCalculator</h4>
The <code>setContainerKey</code> method is renamed to <code>setContainer</code>.
And its semantic changes too. Now the container object is received
instead of the key. In this way this calculator is consistent in EJB2
and POJO (without key classes) versions.
<h2>Migration from OpenXava 1.2 to OpenXava 1.2.1</h2>
<h4>Hibernate generation</h4>
Now when the EJB code generation is done, the hibernate code generation
is
executed too (although the hibernate version still does not work at
100%).<br>
Although you use only EJB version, you have to make this little
adaptation in your project:
<ul>
  <li> Create the folder <code>hibernate</code> in your project. </li>
  <li> Create the file <code>hibernate.cfg.xml</code> inside <code>hibernate</code>
folder. </li>
</ul>
The <code>hibernate.cfg.xml</code> have to be:
<pre>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>   "-//Hibernate/Hibernate Configuration DTD//EN"<br>   "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;<br>  &lt;hibernate-configuration&gt;<br>   &lt;session-factory&gt;<br>       &lt;property name="hibernate.connection.datasource"&gt;@datasource.prefix@/@datasource@&lt;/property&gt;<br>       &lt;property name="hibernate.dialect"&gt;@hibernate.dialect@&lt;/property&gt;<br>       &lt;property name="hibernate.show_sql"&gt;false&lt;/property&gt;<br>   &lt;/session-factory&gt;<br>&lt;/hibernate-configuration&gt;<br></pre>
In addition you have to include the <code>hibernate.dialect</code>
property in your configuration files:
<pre>hibernate.dialect=org.hibernate.dialect.HSQLDialect<br></pre>
<h4>XML OpenXava syntax</h4>
<ul>
  <li> In spanish versi&oacute;n PEQUE&Ntilde;A now is PEQUENA. This is
for avoid problems with ISO-8859-1 versus UTF-8. </li>
</ul>
<h2>Migration from OpenXava 1.1 to OpenXava 1.2</h2>
<h4>Generated code</h4>
<p>
Now EJB remote interface has the suffix <i>Remote</i>, and the
business interface
generated for each component (for example <code>ICustomer</code>) has
no all methods of
the remote interface.<br>
This is for allowing to the future version 2 of OpenXava work with EJB
and
Hibernate in the same project and at same time.<br>
In order to adapt you code to this, you must:
</p>
<ul>
  <li>Delete all generated code </li>
  <li>Regenerate all EJB code </li>
  <li>Build all </li>
  <li>Search and correct all syntax error </li>
</ul>
For correct syntax error you can change code in this way:
<pre><b>Customer</b> customer = CustomerUtil.getHome().findByName("PEPE");<br>String name = customer.getName();<br></pre>
By this:
<pre><b>ICustomer</b> customer = CustomerUtil.getHome().findByName("PEPE");<br>String name = customer.getName();<br></pre>
If you use specific EJB methods then you need cast to remote interface:
<pre><b>Customer</b> customer = CustomerUtil.getHome().findByName("PEPE");<br>CustomerKey key = customer.getPrimaryKey();<br></pre>
By this:
<pre><b>CustomerRemote</b> customer = CustomerUtil.getHome().findByName("PEPE");<br>CustomerKey key = customer.getPrimaryKey();<br></pre>
That is, change <code>Customer</code> by <code>ICustomer</code> when
possible, if not possible change <code>Customer</code> by <code>CustomerRemote</code>.
<p></p>
<h4>JUnit tests</h4>
<ul>
  <li> On deleting an object in a CRUD OpenXava now shows a javascript
windows to confirm, instead of changing to another controller. Hence in
your tests in order to remove an object from CRUD module you only need
use execute("CRUD.delete"). In this case 'yes' is assumed as
confirmation answer. </li>
</ul>
<h4>Others</h4>
<ul>
  <li> Change the name of packages-ejb.properties in gen-src-xava to
packages.properties (or you can simply remove packages-ejb.properties
and regenerate code). </li>
</ul>
<h2>Migration from OpenXava 1.0 to OpenXava 1.1</h2>
<h4>APIs</h4>
<ul>
  <li>MetaView.getMetaViewCollection now is
MetaView.getMetaCollectionView </li>
  <li>MetaView.getMetaViewReference now is
MetaView.getMetaReferenceView </li>
</ul>
<h4>JUnit tests</h4>
<ul>
  <li> Message 'Object deleted successfully' is change by '{0} deleted
successfully'. Hence it's required to change the asserts of this
messages. </li>
</ul>
