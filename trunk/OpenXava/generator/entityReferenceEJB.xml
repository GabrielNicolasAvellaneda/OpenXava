<?xml version="1.0"?>
<tl><declare import="org.openxava.util.*"/>
<declare import="org.openxava.model.meta.*"/>
<declare import="org.openxava.generators.*"/>
<declare import="org.openxava.calculators.*"/>
<declare import="org.openxava.util.meta.MetaSet"/>
<declare import="org.openxava.mapping.*"/>

<declarations>

private MetaReference reference=null;
public void setReference(MetaReference ref) {
	this.reference = ref;
}

private boolean ejb;
public void setEjb(boolean ejb) {
	this.ejb = ejb;
}

private String getExcepcion() {
	return ejb?"EJBException":"RuntimeException";
}


public static void generate(XPathContext context, ProgramWriter out, MetaReference ref) throws XavaException {
	EntityReferenceEJBPG pg = new EntityReferenceEJBPG();
	pg.setReference(ref);
	pg.setEjb(true); // Always true
	pg.generate(context, out);
}

</declarations> 

<java>
MetaModel metaModel = reference.getMetaModel();
ModelMapping modelMapping = null;
if (metaModel instanceof MetaAggregateBean) {
	modelMapping = metaModel.getMetaComponent().getEntityMapping();
}
else {
	modelMapping = metaModel.getMapping();
}	
String referenceName = Strings.firstUpper(reference.getName());
ReferenceMapping referenceMapping = modelMapping.getReferenceMapping(reference.getName());
IMetaEjb referencedModel = (IMetaEjb) reference.getMetaModelReferenced();
ModelMapping referencedMapping = referencedModel.getMapping();
String referencedModelClass = referencedModel.getInterfaceName();
String referencedJNDI = referencedModel.getJndi();
String referencedKeyClass = referencedModel.getPrimaryKey();
String homeClass = referencedModel.getHome();		
String homeAttribute = Strings.firstLower(referenceName) + "Home";
String getHome = "get" + Strings.firstUpper(homeAttribute);		
String interfaceMethodSet = reference.isKey()?"":"@ejb:interface-method";
String pkField = reference.isKey()?"@ejb:pk-field":"";
</java> 

	// <expr>referenceName</expr> : Entity reference/Referencia a entidad
	
	/**
	 * @ejb:interface-method
	 */
	public <expr>referencedModelClass</expr> get<expr>referenceName</expr>() {
		try {		
			return <expr>getHome</expr>().findByPrimaryKey(get<expr>referenceName</expr>Key());
		}
		catch (ObjectNotFoundException ex) {
			return null;
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("get_reference_error", "<expr>referenceName</expr>", "<expr>metaModel.getName()</expr>"));
		}		
	}	
	
	
	/**
	 * @ejb:interface-method
	 */
	public <expr>referencedModel.getRemote()</expr> get<expr>referenceName</expr>Remote() {
		return (<expr>referencedModel.getRemote()</expr>) get<expr>referenceName</expr>();
	}
	
	/**
	 * <expr>interfaceMethodSet</expr>
	 */
	public void set<expr>referenceName</expr>(<expr>referencedModelClass</expr> new<expr>referenceName</expr>) {
<java>if (ejb) { </java> 
		this.modified = true;
<java>} </java> 
		try {	
			if (new<expr>referenceName</expr> == null) set<expr>referenceName</expr>Key(null);
			else {
				<expr>referencedModel.getRemote()</expr> remote = (<expr>referencedModel.getRemote()</expr>) new<expr>referenceName</expr>;
				set<expr>referenceName</expr>Key((<expr>referencedKeyClass</expr>) remote.getPrimaryKey());
			}	
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("set_reference_error", "<expr>referenceName</expr>", "<expr>metaModel.getName()</expr>"));
		}
	}
	
	/**
	 * @ejb:interface-method
	 */
	public <expr>referencedKeyClass</expr> get<expr>referenceName</expr>Key() {				
		<expr>referencedKeyClass</expr> key = new <expr>referencedKeyClass</expr>();
		<java>
		Iterator itKeys = referencedModel.getAllKeyPropertiesNames().iterator();
		while (itKeys.hasNext()) {
			String property = (String) itKeys.next();
			String key = Strings.change(property, ".", "_"); 
			String keyAttribute = null;
			String underline = "";
			if (referencedMapping.hasConverter(key) || property.indexOf('.') &gt;= 0) { 
				keyAttribute = "_" + Strings.firstUpper(key);
				if (!modelMapping.isReferenceOverlappingWithSomeProperty(reference.getName(), property)) {
					underline = "_";
				}
			}
			else {
				keyAttribute = key;
			}
		</java> 
		key.<expr>keyAttribute</expr> = get<expr>underline</expr><expr>referenceName</expr>_<expr>key</expr>();			
		<java>} </java>		
		return key;
	}	
	
	/**
	 * <expr>interfaceMethodSet</expr>
	 */
	public void set<expr>referenceName</expr>Key(<expr>referencedKeyClass</expr> key) {
<java>if (ejb) { </java> 
		this.modified = true;
<java>} </java> 		
		if (key == null) {
			key = new <expr>referencedKeyClass</expr>();
		<java>
		itKeys = referencedModel.getAllKeyPropertiesNames().iterator();		
		while (itKeys.hasNext()) {
		    String property = (String) itKeys.next(); 
			String key = Strings.change(property, ".", "_");
			String keyAttribute=null;
			if (referencedMapping.hasConverter(key) || property.indexOf('.') &gt;= 0) {
				keyAttribute = "_" + Strings.firstUpper(key);
			}
			else {
				keyAttribute = key;
			}
		</java> 
			set<expr>referenceName</expr>_<expr>key</expr>(key.<expr>keyAttribute</expr>);
		<java>} </java>					
		}
		else {
		<java>		
		itKeys = referencedModel.getAllKeyPropertiesNames().iterator();		
		while (itKeys.hasNext()) {
		    String property = (String) itKeys.next(); 
			String key = Strings.change(property, ".", "_");
			String keyAttribute=null;
			String underline = "";
			if (referencedMapping.hasConverter(key) || property.indexOf('.') &gt;= 0) {
				keyAttribute = "_" + Strings.firstUpper(key);
				if (!modelMapping.isReferenceOverlappingWithSomeProperty(reference.getName(), property)) {
					underline = "_";
				}
			}
			else {
				keyAttribute = key;
			}
		</java> 
			set<expr>underline</expr><expr>referenceName</expr>_<expr>key</expr>(key.<expr>keyAttribute</expr>);
		<java>} </java>		
		}
	}	
	
	<java>
	Iterator itEntityReferenceKeyProperties = referencedModel.getAllMetaPropertiesKey().iterator();	
	while (itEntityReferenceKeyProperties.hasNext()) {		
		MetaProperty originalProperty = (MetaProperty) itEntityReferenceKeyProperties.next();
		originalProperty.setReadOnly(false);
		PropertyMapping propertyMapping = originalProperty.getMapping();
		MetaProperty property = originalProperty.cloneMetaProperty();
		property.setName(reference.getName() + "_" + property.getName());
		String propertyName = Strings.change(Strings.firstUpper(property.getName()), ".", "_");
		if (GeneratorFactory.has(property, ejb)) {
			IPropertyCodeGenerator generator = GeneratorFactory.create(property, ejb);		
			String propertyCode = generator.generate();
	</java>
		<expr>propertyCode</expr>	
	<java>		
			continue;
		}
		else if (modelMapping.isReferenceOverlappingWithSomeProperty(reference.getName(), originalProperty.getName())) { 
			String type = property.getTypeName();
			String overlapPropertyName = Strings.firstUpper(modelMapping.getOverlappingPropertyForReference(reference.getName(), originalProperty.getName()));
	</java>
	/**		
	 * @ejb:interface-method
	 *
	 * @ejb.value-object match="persistentCalculatedAndAggregate"
	 */
	public <expr>type</expr> get<expr>propertyName</expr>() {
		return get<expr>overlapPropertyName</expr>();
	}
	public void set<expr>propertyName</expr>(<expr>type</expr> <expr>propertyName</expr>) {
	}
	<java>					
			continue;
		}		
		String type = null;
		if (propertyMapping.hasConverter()) {
			type = propertyMapping.getCmpTypeName();
		}
		else {
			type = property.getTypeName();
		}	
		String column = referenceMapping.getColumnForReferencedModelProperty(originalProperty.getName());			
		String cmpType = referenceMapping.getCmpTypeNameForReferencedModelProperty(originalProperty.getName()); 
		if (Is.emptyString(cmpType)) cmpType = type;
	</java>
	/**		
	 * @ejb:persistent-field
	 * <expr>pkField</expr>
	 * @jboss:column-name "<expr>column</expr>"
	 */
	public abstract <expr>cmpType</expr> get_<expr>propertyName</expr>();
	public abstract void set_<expr>propertyName</expr>(<expr>cmpType</expr> new<expr>propertyName</expr>);

	/**		
	 * @ejb:interface-method
	 * @ejb.value-object match="persistentCalculatedAndAggregate"
	 */
	public <expr>type</expr> get<expr>propertyName</expr>() {
		<java>
		if (referenceMapping.hasConverter(originalProperty.getName())) {			
			String getSentence = property.getName() + "Converter.toJava(get_" + propertyName + "())";							
		</java> 
		try {
			return <expr>Generators.generateCast(type, getSentence)</expr>;
		}
		catch (org.openxava.converters.ConversionException ex) {
			ex.printStackTrace();
			throw new <expr>getExcepcion()</expr>(XavaResources.getString("generator.conversion_error", "<expr>reference.getName()</expr>.<expr>originalProperty.getName()</expr>", "<expr>metaModel.getName()</expr>", "<expr>type</expr>"));
		}		
		<java>} else { </java> 
		return get_<expr>propertyName</expr>(); 				
		<java>} </java> 
	}
	public void set<expr>propertyName</expr>(<expr>type</expr> new<expr>propertyName</expr>) {
		<java>
		if (referenceMapping.hasConverter(originalProperty.getName())) {			
			String argv = Generators.generatePrimitiveWrapper(type, "new" + propertyName);			
			String sentence = property.getName() + "Converter.toDB(" + argv + ")";
		</java> 
		try {
			set_<expr>propertyName</expr>(<expr>Generators.generateCast(cmpType, sentence)</expr>);
		}
		catch (org.openxava.converters.ConversionException ex) {
			ex.printStackTrace();
			throw new <expr>getExcepcion()</expr>(XavaResources.getString("generator.conversion_error", "<expr>reference.getName()</expr>.<expr>originalProperty.getName()</expr>", "<expr>metaModel.getName()</expr>", "<expr>type</expr>"));
		}		
		<java>} else { </java> 
		set_<expr>propertyName</expr>(new<expr>propertyName</expr>); 				
		<java>} </java> 	
	}

					
	<java>} // while referenced entity key properties </java> 

	private <expr>homeClass</expr> <expr>homeAttribute</expr>;	
	private <expr>homeClass</expr> <expr>getHome</expr>() throws Exception{
		if (<expr>homeAttribute</expr> == null) {
			<expr>homeAttribute</expr> = (<expr>homeClass</expr>) PortableRemoteObject.narrow(
			 		BeansContext.get().lookup("<expr>referencedJNDI</expr>"),
			 		<expr>homeClass</expr>.class);			 		
		}
		return <expr>homeAttribute</expr>;
	}	

	<java>
	for (Iterator it = referenceMapping.getDetails().iterator(); it.hasNext(); ) {	
		ReferenceMappingDetail detail = (ReferenceMappingDetail) it.next();
		if (detail.hasConverter()) {
			String key = Strings.change(detail.getReferencedModelProperty(), ".", "_");
	</java> 
	
	private static final <expr>detail.getConverterClassName()</expr> 
		<expr>reference.getName()</expr>_<expr>key</expr>Converter =
			new <expr>detail.getConverterClassName()</expr>();
	<java>
		}
	}
	</java> 
	
	</tl>