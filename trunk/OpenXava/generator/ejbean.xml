<?xml version="1.0"?>
<tl><declare import="org.openxava.util.Strings"/>
<declare import="org.openxava.util.XavaException"/>
<declare import="org.openxava.util.meta.MetaSet"/>
<declare import="org.openxava.component.MetaComponent"/>
<declare import="org.openxava.model.meta.*"/>
<declare import="org.openxava.calculators.*"/>
<declare import="org.openxava.generators.*"/>
<declare import="org.openxava.mapping.*"/>

<declarations>

private String generateFinderArguments(Collection metaProperties) throws XavaException {
	Iterator it = metaProperties.iterator();
	StringBuffer result = new StringBuffer();
	while (it.hasNext()) {		
		MetaProperty pr = (MetaProperty) it.next();
		result.append("get");
		result.append(Strings.firstUpper(pr.getName()));
		result.append("()");
		if (it.hasNext()) {
			result.append(", ");
		}		
	}
	return result.toString();
}

private String generateFinderArgumentsByKey(IMetaModel model) throws XavaException {
	Iterator it = model.getAllKeyPropertiesNames().iterator();
	StringBuffer result = new StringBuffer();
	while (it.hasNext()) {		
		result.append("get");
		result.append(Strings.change(Strings.firstUpper((String) it.next()), ".", "_"));
		result.append("()");
		if (it.hasNext()) {
			result.append(", ");
		}		
	}
	return result.toString();
}

private String generateFinderArgumentsByKeyDeclaration(IMetaModel model) throws XavaException {
	Iterator it = model.getAllKeyPropertiesNames().iterator();
	StringBuffer result = new StringBuffer();
	while (it.hasNext()) {		
		String propertyName = (String) it.next();
		MetaProperty metaProperty = model.getMetaProperty(propertyName);
		result.append(metaProperty.getCMPTypeName());
		result.append(' ');
		result.append(Strings.change(propertyName, ".", "_"));
		if (it.hasNext()) {
			result.append(", ");
		}		
	}
	return result.toString();
}

private String generateEJBQLforReference(IMetaModel model, String referenceName) throws XavaException {
	StringBuffer result = new StringBuffer("SELECT OBJECT(o) FROM ");
	result.append(model.getName());
	result.append(" o WHERE ");
	ModelMapping mapping = model.getMapping();
	ReferenceMapping referenceMapping = mapping.getReferenceMapping(referenceName);
	int n = 0;
	MetaModel referencedModel = model.getMetaReference(referenceName).getMetaModelReferenced();
	Iterator it = referencedModel.getAllKeyPropertiesNames().iterator();
	while (it.hasNext()) {		
		String propertyName = (String) it.next();		
		result.append("o."); 
		String cmpAttribute = referenceMapping.getCMPAttribute(propertyName);
		result.append(cmpAttribute); 
		result.append(" = ?");		
		result.append(++n);
		if (it.hasNext()) {
			result.append(" AND ");
		}		
	}
	return result.toString();
}


</declarations>

<java>
String packageName = properties.getProperty("arg3");
String componentName = properties.getProperty("arg4");
String aggregateName = properties.getProperty("arg5");
MetaComponent component = MetaComponent.get(componentName);
String name=null;
IMetaEjb metaModel=null;
ModelMapping modelMapping=null;
boolean reentrant;
if (aggregateName == null) {
	name=componentName;	
	metaModel = (IMetaEjb) component.getMetaEntity();
	modelMapping = component.getEntityMapping();
	reentrant = false;	
}
else {
	name=aggregateName;
	metaModel =  (IMetaEjb)component.getMetaAggregate(aggregateName);
	modelMapping = component.getAggregateMapping(aggregateName);	
	reentrant = true;
}


String jndi = metaModel.getJndi();
String table = modelMapping.getTable();
String keyClass = metaModel.getPrimaryKey();
</java>
// File generated by OpenXava: <expr>new Date()</expr>
// Archivo generado por OpenXava: <expr>new Date()</expr>

// WARNING: NO EDIT
// OJO: NO EDITAR

<java>if (aggregateName == null) { </java>
// Component: <expr>componentName</expr>		Entity/Entidad
<java>} else { </java>
// Component: <expr>componentName</expr>		Aggregate/Agregado: <expr>aggregateName</expr>
<java>} </java>

package <expr>packageName</expr>.xejb;

import java.util.*;
import java.math.*;
import javax.ejb.*;
import javax.rmi.PortableRemoteObject;

import org.openxava.ejbx.*;
import org.openxava.util.*;
import org.openxava.component.*;
import org.openxava.model.meta.*;
import org.openxava.validators.ValidationException;

import <expr>packageName</expr>.*;


/**
 * @ejb:bean name="<expr>name</expr>" type="CMP" jndi-name="@subcontext@/<expr>jndi</expr>" reentrant="<expr>reentrant</expr>" view-type="remote"
 * @ejb:interface extends="org.openxava.ejbx.EJBReplicable, <expr>packageName</expr>.I<expr>name</expr>"
 * @ejb:data-object extends="java.lang.Object"
 * @ejb:home extends="javax.ejb.EJBHome"
 * @ejb:pk extends="java.lang.Object"
 *
 * @ejb.value-object name="<expr>name</expr>" match="persistentCalculatedAndAggregate"
 *   
 * @ejb:env-entry name="DATA_SOURCE" type="java.lang.String" value="jdbc/DataSource"
 * @ejb:resource-ref  res-name="jdbc/DataSource" res-type="javax.sql.DataSource"  res-auth="Container" jndi-name="jdbc/@datasource@"
 * @jboss:resource-ref  res-ref-name="jdbc/DataSource" resource-name="jdbc/DataSource"
 *
 <java>
 // Finders for references
 Iterator itEntityReferences = metaModel.getMetaReferencesWithMapping().iterator(); 
 while (itEntityReferences.hasNext()) {
 	MetaReference reference = (MetaReference) itEntityReferences.next();
 	String referenceName = Strings.firstUpper(reference.getName());
 	MetaModel referencedModel = reference.getMetaModelReferenced();
 	String arguments = generateFinderArgumentsByKeyDeclaration(referencedModel);
 	String condition = generateEJBQLforReference(metaModel, reference.getName());
	String conditionWithOrder = condition + " " + reference.getEJBQLOrderFromReferencedModel();
 </java> 	
 * @ejb:finder signature="Collection findBy<expr>referenceName</expr>(<expr>arguments</expr>)" query="<expr>conditionWithOrder</expr>" view-type="remote" result-type-mapping="Remote"
 * @jboss:query signature="Collection findBy<expr>referenceName</expr>(<expr>arguments</expr>)" query="<expr>conditionWithOrder</expr>"
 <java>} 
// Finders for collections with condition
 Iterator itCollectionsWithCondition = metaModel.getMetaCollectionsWithConditionInOthersModels().iterator(); 
 while (itCollectionsWithCondition.hasNext()) {
 	MetaCollection collection = (MetaCollection) itCollectionsWithCondition.next();	
 	String condition = collection.getEJBQLCondition();
	String finderName = collection.getFinderName();
	String arguments = collection.getFinderArguments();
 </java> 	
 * @ejb:finder signature="Collection find<expr>finderName</expr>(<expr>arguments</expr>)" query="<expr>condition</expr>" view-type="remote" result-type-mapping="Remote"
 * @jboss:query signature="Collection find<expr>finderName</expr>(<expr>arguments</expr>)" query="<expr>condition</expr>" 
 <java>}  
 // User defined finders
 Iterator itFinders = metaModel.getMetaFinders().iterator();
 while (itFinders.hasNext()) {
 	MetaFinder finder = (MetaFinder) itFinders.next();
 	String finderName = Strings.firstUpper(finder.getName());
 	String arguments = finder.getArguments();
 	String condition = finder.getEJBQLCondition(); 	
 	String type = finder.isCollection()?"Collection":name;
 </java> 	
 * @ejb:finder signature="<expr>type</expr> find<expr>finderName</expr>(<expr>arguments</expr>)" query="<expr>condition</expr>" view-type="remote" result-type-mapping="Remote"
 * @jboss:query signature="<expr>type</expr> find<expr>finderName</expr>(<expr>arguments</expr>)" query="<expr>condition</expr>"
 <java>} </java> 
 * 
 * @jboss:table-name "<expr>table</expr>"
 *
 * @author Javier Paniza
 */
abstract public class <expr>name</expr>Bean extends EJBReplicableBase 
			implements <expr>packageName</expr>.I<expr>name</expr>, EntityBean {	
			
	private boolean creating = false;		
	private boolean modified = false;

	// Create	

	<java>	
	// For the aggregates
	IMetaEjb containerModel = (IMetaEjb) metaModel.getMetaModelContainer();
	String containerName = containerModel.getName();
	String containerClass = containerModel.getRemote();
	String containerKeyClass = containerModel.getPrimaryKey();
	</java> 

	/**
	 * @ejb:create-method
	 */
	<java>if (aggregateName == null) { </java>	 
	public <expr>keyClass</expr> ejbCreate(Map values)
	<java>} else { 	</java> 
	public <expr>keyClass</expr> ejbCreate(<expr>containerClass</expr> container, int counter, Map values)	
	<java>} </java> 
		throws
			CreateException,
			ValidationException {
		initMembers();	
		creating = true;	
		modified = false;
		executeSets(values);
	<java>if (aggregateName != null) { </java> 
		<expr>containerKeyClass</expr> containerKey = null;
		try {
			containerKey = (<expr>containerKeyClass</expr>) container.getPrimaryKey();
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("obtain_primary_key_error_on_create", "<expr>componentName</expr>", "<expr>aggregateName</expr>"));
		}		
		<java>
		Iterator it = containerModel.getAllKeyPropertiesNames().iterator();
		while (it.hasNext()) {
			String propertyName = (String) it.next(); 
			String propertyNameInKey = propertyName;
			if (propertyName.indexOf('.') &gt;= 0) {				
				propertyName = Strings.change(propertyName, ".", "_");
				propertyNameInKey = "_" + Strings.firstUpper(propertyName);
			}						
		</java> 
		set<expr>containerName</expr>_<expr>propertyName</expr>(containerKey.<expr>propertyNameInKey</expr>);
		<java>} </java> 
			
	<java>} 
		Collection properties = metaModel.getMetaPropertiesWithDefaultValueOnCreate();					
		if (!properties.isEmpty()) {
		</java> 
		try {
		<java>
		}
		Iterator itDefaultValueProperties = properties.iterator(); 
		while (itDefaultValueProperties.hasNext()) {
			MetaProperty property = (MetaProperty) itDefaultValueProperties.next();			
			String propertyName = Strings.firstUpper(property.getName());
			MetaCalculator calculator = property.getMetaCalculatorDefaultValue();
			String calculatorClass = calculator.getClassName();
		</java> 	
			<expr>calculatorClass</expr> <expr>property.getName()</expr>Calculator = (<expr>calculatorClass</expr>)
				getMetaModel().getMetaProperty("<expr>property.getName()</expr>").getMetaCalculatorDefaultValue().getCalculator();
		<java>
			Iterator itSets = calculator.getMetaSetsWithoutValue().iterator();
			while (itSets.hasNext()) {
				MetaSet set = (MetaSet) itSets.next();
				String propertyNameInCalculator = Strings.firstUpper(set.getPropertyName());
				String propertyNameFrom = Strings.firstUpper(set.getPropertyNameFrom());
		</java> 	
			<expr>property.getName()</expr>Calculator.set<expr>propertyNameInCalculator</expr>(get<expr>propertyNameFrom</expr>());
		<java>	} // sets 
		if (IAggregateOidCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
		</java> 
			<expr>property.getName()</expr>Calculator.setContainerKey(containerKey);
			<expr>property.getName()</expr>Calculator.setCounter(counter);	
		<java>	
		} 
		else if (IJDBCCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) {
		</java> 
			<expr>property.getName()</expr>Calculator.setConnectionProvider(getPortableContext());
		<java>
		}
		else if (IEntityCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
		</java> 
			<expr>property.getName()</expr>Calculator.setEntity(this);
		<java> 		
		}		
		String calculateValueSentence = property.getName() + "Calculator.calculate()";		
		</java> 
			set<expr>propertyName</expr>(<expr>Generators.generateCast(property.getTypeName(), calculateValueSentence)</expr>);
		<java>} //properties 				
		if (!properties.isEmpty()) {
		</java> 
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("entity_create_error", "<expr>name</expr>", ex.getLocalizedMessage()));
		}		
		<java>} // if </java> 
			
		return null;
	}

	<java>if (aggregateName == null) { </java> 
	public void ejbPostCreate(Map values)
	<java>} else { </java> 
	public void ejbPostCreate(<expr>containerClass</expr> container, int counter, Map values)	
	<java>} </java> 
		throws
			CreateException,
			ValidationException {
		<java>PostcreatePG.generate(context, out, metaModel); </java> 
	}	
	
	 		
		
<java>if (aggregateName != null) { </java> 
	/**
	 * @ejb:create-method
	 */
	public <expr>keyClass</expr> ejbCreate(<expr>containerKeyClass</expr> containerKey, int counter, Map values)	
		throws
			CreateException,
			ValidationException {
		initMembers();	
		creating = true;
		modified = false;
		executeSets(values);
		<java>
		Iterator it = containerModel.getAllKeyPropertiesNames().iterator();
		while (it.hasNext()) {
			String propertyName = (String) it.next();
			String propertyNameInKey = propertyName; 
			if (propertyName.indexOf('.') &gt;= 0) {
				propertyName= Strings.change(propertyName, ".", "_");
				propertyNameInKey = "_" + Strings.firstUpper(propertyName);
			}
		</java> 
		set<expr>containerName</expr>_<expr>propertyName</expr>(containerKey.<expr>propertyNameInKey</expr>);		
		<java>}  
			
		properties = metaModel.getMetaPropertiesWithDefaultValueOnCreate();					
		if (!properties.isEmpty()) {
		</java> 
		try {
		<java>
		}
		itDefaultValueProperties = properties.iterator(); 
		while (itDefaultValueProperties.hasNext()) {
			MetaProperty property = (MetaProperty) itDefaultValueProperties.next();
			String propertyName = Strings.firstUpper(property.getName());
			MetaCalculator calculator = property.getMetaCalculatorDefaultValue();
			String calculatorClass = calculator.getClassName();
		</java> 	
			<expr>calculatorClass</expr> <expr>property.getName()</expr>Calculator = (<expr>calculatorClass</expr>)
				getMetaModel().getMetaProperty("<expr>property.getName()</expr>").getMetaCalculatorDefaultValue().getCalculator();
		<java>
			Iterator itSets = calculator.getMetaSetsWithoutValue().iterator();
			while (itSets.hasNext()) {
				MetaSet set = (MetaSet) itSets.next();
				String propertyNameInCalculator = Strings.firstUpper(set.getPropertyName());
				String propertyNameFrom = Strings.firstUpper(set.getPropertyNameFrom());
		</java> 	
			<expr>property.getName()</expr>Calculator.set<expr>propertyNameInCalculator</expr>(get<expr>propertyNameFrom</expr>());
		<java>	} // sets 
		if (IAggregateOidCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
		</java> 
			<expr>property.getName()</expr>Calculator.setContainerKey(containerKey);
			<expr>property.getName()</expr>Calculator.setCounter(counter);	
		<java>	
		} 
		else if (IJDBCCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) {
		</java> 
			<expr>property.getName()</expr>Calculator.setConnectionProvider(getPortableContext());
		<java>
		}
		else if (IEntityCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
		</java> 
			<expr>property.getName()</expr>Calculator.setEntity(this);
		<java> 		
		}		
		String calculateValueSentence = property.getName() + "Calculator.calculate()";		
		</java> 
			set<expr>propertyName</expr>(<expr>Generators.generateCast(property.getTypeName(), calculateValueSentence)</expr>);
		<java>} // properties 				
		if (!properties.isEmpty()) {
		</java> 
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("entity_create_error", "<expr>name</expr>", ex.getLocalizedMessage()));
		}		
		<java>} // if </java> 
			
		return null;
	}

	public void ejbPostCreate(<expr>containerKeyClass</expr> containerKey, int counter, Map values)	
		throws
			CreateException,
			ValidationException {
		<java>PostcreatePG.generate(context, out, metaModel); </java>			
	}

<java>} </java> 
	
	/**
	 * @ejb:create-method
	 */
	<java>if (aggregateName == null) { </java>	 
	public <expr>keyClass</expr> ejbCreate(<expr>packageName</expr>.<expr>name</expr>Data data)
	<java>} else { 	</java> 
	public <expr>keyClass</expr> ejbCreate(<expr>containerClass</expr> container, int counter, <expr>packageName</expr>.<expr>name</expr>Data data)	
	<java>} </java> 
		throws
			CreateException,
			ValidationException {
		initMembers();	
		creating = true;	
		modified = false;
		setData(data);	
	<java>if (aggregateName != null) { </java> 
		<expr>containerKeyClass</expr> containerKey = null;
		try {
			containerKey = (<expr>containerKeyClass</expr>) container.getPrimaryKey();
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("obtain_primary_key_error_on_create", "<expr>componentName</expr>", "<expr>aggregateName</expr>"));
		}		
		<java>
		Iterator it = containerModel.getAllKeyPropertiesNames().iterator();
		while (it.hasNext()) {
			String originalName = (String) it.next();
			if (containerModel.getMapping().isReferencePropertyOverlappingWithSomeProperty(originalName)) continue;
			String propertyName = originalName; 
			String propertyNameInKey = originalName; 
			if (originalName.indexOf('.') &gt;= 0) { 
				propertyName = Strings.change(originalName, ".", "_");
				propertyNameInKey = "_" + Strings.firstUpper(propertyName);				
			}
		</java> 
		set<expr>containerName</expr>_<expr>propertyName</expr>(containerKey.<expr>propertyNameInKey</expr>);		
		<java>} </java> 
			
	<java>} 
	  else { // It isn't aggregate
		Iterator itKeyProperties = metaModel.getAllKeyPropertiesNames().iterator();
		while (itKeyProperties.hasNext()) {
			String keyProperty = (String) itKeyProperties.next();
			if (modelMapping.isReferencePropertyOverlappingWithSomeProperty(keyProperty)) continue;
			String propertyName = Strings.change(Strings.firstUpper(keyProperty), ".", "_");
			if (modelMapping.hasConverter(keyProperty) || keyProperty.indexOf('.') &gt;= 0) { 
		</java>  
		set_<expr>propertyName</expr>(data.get_<expr>propertyName</expr>());		
		<java>			
			}
			else {
		</java> 
		set<expr>propertyName</expr>(data.get<expr>propertyName</expr>());		
		<java>
			} 
		  } 
		} // else if has aggregate
		properties = metaModel.getMetaPropertiesWithDefaultValueOnCreate();					
		if (!properties.isEmpty()) {
		</java> 
		try {
		<java>
		}
		itDefaultValueProperties = properties.iterator(); 
		while (itDefaultValueProperties.hasNext()) {
			MetaProperty property = (MetaProperty) itDefaultValueProperties.next();
			String propertyName = Strings.firstUpper(property.getName());
			MetaCalculator calculator = property.getMetaCalculatorDefaultValue();
			String calculatorClass = calculator.getClassName();
		</java> 	
			<expr>calculatorClass</expr> <expr>property.getName()</expr>Calculator= (<expr>calculatorClass</expr>)
				getMetaModel().getMetaProperty("<expr>property.getName()</expr>").getMetaCalculatorDefaultValue().getCalculator();
		<java>
			Iterator itSets = calculator.getMetaSetsWithoutValue().iterator();
			while (itSets.hasNext()) {
				MetaSet set = (MetaSet) itSets.next();
				String propertyNameInCalculator = Strings.firstUpper(set.getPropertyName());
				String propertyNameFrom = Strings.firstUpper(set.getPropertyNameFrom());
		</java> 	
			<expr>property.getName()</expr>Calculator.set<expr>propertyNameInCalculator</expr>(get<expr>propertyNameFrom</expr>());
		<java>	} // poners 
		if (IAggregateOidCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
		</java> 
			<expr>property.getName()</expr>Calculator.setContainerKey(containerKey);
			<expr>property.getName()</expr>Calculator.setCounter(counter);	
		<java>	
		}
		else if (IJDBCCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) {
		</java> 
			<expr>property.getName()</expr>Calculator.setConnectionProvider(getPortableContext());
		<java>		
		}
		else if (IEntityCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
		</java> 
			<expr>property.getName()</expr>Calculator.setEntity(this);
		<java> 				
		}		
		String calculateValueSentence = property.getName() + "Calculator.calculate()";		
		</java> 
			set<expr>propertyName</expr>(<expr>Generators.generateCast(property.getTypeName(), calculateValueSentence)</expr>);
		<java>} //properties 				
		if (!properties.isEmpty()) {
		</java> 
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("entity_create_error", "<expr>name</expr>", ex.getLocalizedMessage()));
		}		
		<java>} // if </java> 
			
		return null;
	}

	<java>if (aggregateName == null) { </java> 
	public void ejbPostCreate(<expr>packageName</expr>.<expr>name</expr>Data data)
	<java>} else { </java> 
	public void ejbPostCreate(<expr>containerClass</expr> container, int counter, <expr>packageName</expr>.<expr>name</expr>Data data)	
	<java>} </java> 
		throws
			CreateException,
			ValidationException {
		<java>PostcreatePG.generate(context, out, metaModel); </java>			
	}
	
	
	/**
	 * @ejb:create-method
	 */
	<java>if (aggregateName == null) { </java>	 
	public <expr>keyClass</expr> ejbCreate(<expr>packageName</expr>.<expr>name</expr>Value value)
	<java>} else { 	</java> 
	public <expr>keyClass</expr> ejbCreate(<expr>containerClass</expr> container, int counter, <expr>packageName</expr>.<expr>name</expr>Value value)	
	<java>} </java> 
		throws
			CreateException,
			ValidationException {
		initMembers();	
		creating = true;	
		modified = false;
		set<expr>name</expr>Value(value);	
		<java>
		Iterator itKeyProperties = metaModel.getAllKeyPropertiesNames().iterator();
		while (itKeyProperties.hasNext()) {
			String propertyName = (String) itKeyProperties.next();
			propertyName = Strings.firstUpper(Strings.change(propertyName, ".", "_"));
		</java> 
		set<expr>propertyName</expr>(value.get<expr>propertyName</expr>());
		<java>} </java> 		
	<java>if (aggregateName != null) { </java> 
		<expr>containerKeyClass</expr> containerKey = null;
		try {
			containerKey = (<expr>containerKeyClass</expr>) container.getPrimaryKey();
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("obtain_primary_key_error_on_create", "<expr>componentName</expr>", "<expr>aggregateName</expr>"));
		}		
		<java>
		Iterator it = containerModel.getAllKeyPropertiesNames().iterator();
		while (it.hasNext()) {
			String propertyName = (String) it.next();
			String propertyNameInKey = propertyName;
			if (propertyName.indexOf('.') &gt;= 0) {
				propertyName = Strings.change(propertyName, ".", "_");
				propertyNameInKey = "_" + Strings.firstUpper(propertyName);
			}
		</java> 
		set<expr>containerName</expr>_<expr>propertyName</expr>(containerKey.<expr>propertyNameInKey</expr>);		
		<java>} </java> 
			
	<java>} // if has aggregate
		properties = metaModel.getMetaPropertiesWithDefaultValueOnCreate();					
		if (!properties.isEmpty()) {
		</java> 
		try {
		<java>
		}
		itDefaultValueProperties = properties.iterator(); 
		while (itDefaultValueProperties.hasNext()) {
			MetaProperty property = (MetaProperty) itDefaultValueProperties.next();
			String propertyName = Strings.firstUpper(property.getName());
			MetaCalculator calculator = property.getMetaCalculatorDefaultValue();
			String calculatorClass = calculator.getClassName();
		</java> 	
			<expr>calculatorClass</expr> <expr>property.getName()</expr>Calculator = (<expr>calculatorClass</expr>)
				getMetaModel().getMetaProperty("<expr>property.getName()</expr>").getMetaCalculatorDefaultValue().getCalculator();
		<java>
			Iterator itSets = calculator.getMetaSetsWithoutValue().iterator();
			while (itSets.hasNext()) {
				MetaSet set = (MetaSet) itSets.next();
				String propertyNameInCalculator = Strings.firstUpper(set.getPropertyName());
				String propertyNameFrom = Strings.firstUpper(set.getPropertyNameFrom());
		</java> 	
			<expr>property.getName()</expr>Calculator.set<expr>propertyNameInCalculator</expr>(get<expr>propertyNameFrom</expr>());
		<java>	} // sets 
		if (IAggregateOidCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
		</java> 
			<expr>property.getName()</expr>Calculator.setContainerKey(containerKey);
			<expr>property.getName()</expr>Calculator.setCounter(counter);	
		<java>	
		}
		else if (IJDBCCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) {
		</java> 
			<expr>property.getName()</expr>Calculator.setConnectionProvider(getPortableContext());
		<java>		
		}
		else if (IEntityCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
		</java> 
			<expr>property.getName()</expr>Calculator.setEntity(this);
		<java> 				
		}
		String calculateValueSentence = property.getName() + "Calculator.calculate()";		
		</java> 
			set<expr>propertyName</expr>(<expr>Generators.generateCast(property.getTypeName(), calculateValueSentence)</expr>);
		<java>} //property
		if (!properties.isEmpty()) {
		</java> 
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("entity_create_error", "<expr>name</expr>", ex.getLocalizedMessage()));
		}		
		<java>} // if </java> 
			
		return null;
	}

	<java>if (aggregateName == null) { </java> 
	public void ejbPostCreate(<expr>packageName</expr>.<expr>name</expr>Value value)
	<java>} else { </java> 
	public void ejbPostCreate(<expr>containerClass</expr> container, int counter, <expr>packageName</expr>.<expr>name</expr>Value value)	
	<java>} </java> 
		throws
			CreateException,
			ValidationException {
		<java>PostcreatePG.generate(context, out, metaModel); </java>			
	}
	
	<java>if (aggregateName != null) { </java>	 
	/**
	 * @ejb:create-method
	 */
	public <expr>keyClass</expr> ejbCreate(<expr>containerKeyClass</expr> containerKey, int counter, <expr>packageName</expr>.<expr>name</expr>Value value)
		throws
			CreateException,
			ValidationException {
		initMembers();	
		creating = true;
		modified = false;
		set<expr>name</expr>Value(value);
		<java>
		itKeyProperties = metaModel.getAllKeyPropertiesNames().iterator();
		while (itKeyProperties.hasNext()) {
			String propertyName = Strings.change(Strings.firstUpper((String) itKeyProperties.next()), ".", "_");						
		</java> 
		set<expr>propertyName</expr>(value.get<expr>propertyName</expr>()); 
		<java>
		} 
		
		Iterator it = containerModel.getAllKeyPropertiesNames().iterator();
		while (it.hasNext()) {
			String propertyName = (String) it.next();
			String propertyNameInKey = propertyName;
			if (propertyName.indexOf('.') &gt;= 0) {
				propertyName = Strings.change(propertyName, ".", "_");
				propertyNameInKey = "_" + Strings.firstUpper(propertyName);
			}
		</java>
		set<expr>containerName</expr>_<expr>propertyName</expr>(containerKey.<expr>propertyNameInKey</expr>);
		<java>} 
		properties = metaModel.getMetaPropertiesWithDefaultValueOnCreate();
		if (!properties.isEmpty()) {
		</java> 
		try {
		<java>
		}
		itDefaultValueProperties = properties.iterator();
		while (itDefaultValueProperties.hasNext()) {
			MetaProperty property = (MetaProperty) itDefaultValueProperties.next();
			String propertyName = Strings.firstUpper(property.getName());
			MetaCalculator calculator = property.getMetaCalculatorDefaultValue();
			String calculatorClass = calculator.getClassName();
		</java> 
			<expr>calculatorClass</expr> <expr>property.getName()</expr>Calculator= (<expr>calculatorClass</expr>)
				getMetaModel().getMetaProperty("<expr>property.getName()</expr>").getMetaCalculatorDefaultValue().getCalculator();
		<java>
			Iterator itSets = calculator.getMetaSetsWithoutValue().iterator();
			while (itSets.hasNext()) {
				MetaSet set = (MetaSet) itSets.next();
				String propertyNameInCalculator = Strings.firstUpper(set.getPropertyName());
				String propertyNameFrom = Strings.firstUpper(set.getPropertyNameFrom());
		</java> 
			<expr>property.getName()</expr>Calculator.set<expr>propertyNameInCalculator</expr>(get<expr>propertyNameFrom</expr>());
		<java>	} // sets
		if (IAggregateOidCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) {
		</java> 
			<expr>property.getName()</expr>Calculator.setContainerKey(containerKey);
			<expr>property.getName()</expr>Calculator.setCounter(counter);
		<java>
		}
		else if (IJDBCCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) {
		</java> 
			<expr>property.getName()</expr>Calculator.setConnectionProvider(getPortableContext());
		<java>
		}
		else if (IEntityCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
		</java> 
			<expr>property.getName()</expr>Calculator.setEntity(this);
		<java> 				
		}
		
		String calculateValueSentence = property.getName() + "Calculator.calculate()";
		</java> 
			set<expr>propertyName</expr>(<expr>Generators.generateCast(property.getTypeName(), calculateValueSentence)</expr>);
		<java>} // properties
		
		if (!properties.isEmpty()) {
		</java>
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("entity_create_error", "<expr>name</expr>", ex.getLocalizedMessage()));
		}
		<java>} // if </java> 
		return null;					

	}	
	<java>} </java> 

	<java>if (aggregateName != null) { </java> 
	public void ejbPostCreate(<expr>containerKeyClass</expr> containerKey, int counter, <expr>packageName</expr>.<expr>name</expr>Value value)	
		throws
			CreateException,
			ValidationException {
		<java>PostcreatePG.generate(context, out, metaModel); </java>			
	}	
	<java>} </java>
	
	public void ejbLoad() {
		creating = false;
		modified = false;
	}
	
	public void ejbStore() {
		if (creating) {
			creating = false;
			return;
		}
		if (!modified) return;
		
		<java>PostmodifyPG.generate(context, out, metaModel); </java>			
		
		modified = false;
	} 	
	
	// Properties/Propiedades
	
<java>
Iterator itProperties = metaModel.getMetaProperties().iterator();	
while (itProperties.hasNext()) {	
	MetaProperty property = (MetaProperty) itProperties.next();
	PropertyPG.generateEJB(context, out, property); 
}
</java> 

	// Colecciones/Collections
	
<java>
Iterator itCollections = metaModel.getMetaCollections().iterator();	
while (itCollections.hasNext()) {	
	MetaCollection collection = (MetaCollection) itCollections.next();
	String collectionName = Strings.firstUpper(collection.getName());
	MetaReference reference = collection.getMetaReference();	
	IMetaEjb referencedModel = (IMetaEjb) reference.getMetaModelReferenced();
	String homeClass = referencedModel.getHome();
	String referencedModelName = reference.getReferencedModelName();
	String referencedModelClass = referencedModel.getRemote();
	String referencedJNDI = referencedModel.getJndi();
	String homeAttribute = Strings.firstLower(collectionName) + "Home";
	String getHome = "get" + Strings.firstUpper(homeAttribute);
	String role = Strings.firstUpper(reference.getRole());
	String finderName = collection.hasCondition()?collection.getFinderName():"By" + role;
	String finderArguments = collection.hasCondition()?generateFinderArguments(collection.getMetaPropertiesFinderArguments()):generateFinderArgumentsByKey(metaModel);		
</java>	

	private <expr>homeClass</expr> <expr>homeAttribute</expr>;

<java>if (!reference.isAggregate() &amp;&amp; 
	!collection.hasCondition() &amp;&amp; 
	!collection.hasCalculator() &amp;&amp; 
	!reference.getMetaModelReferenced().getMetaReference(reference.getRole()).isKey()) { </java>
	/**
	 * @ejb:interface-method
	 */
	public void addTo<expr>collectionName</expr>(<expr>referencedModelClass</expr> newElement) {
		if (newElement != null) { 
			try {
				newElement.set<expr>role</expr>Key((<expr>keyClass</expr>) getEntityContext().getPrimaryKey());
			}
			catch (Exception ex) {
				ex.printStackTrace();
				throw new EJBException(XavaResources.getString("add_collection_element_error", "<expr>referencedModelName</expr>", "<expr>name</expr>"));
			}
		}
	}
	
	/**
	 * @ejb:interface-method
	 */
	public void removeFrom<expr>collectionName</expr>(<expr>referencedModelClass</expr> toRemove) {
		if (toRemove != null) {
			try {
				toRemove.set<expr>role</expr>Key(null);
			}
			catch (Exception ex) {
				ex.printStackTrace();
				throw new EJBException(XavaResources.getString("remove_collection_element_error", "<expr>referencedModelName</expr>", "<expr>name</expr>"));
			}
		}
	}
	
<java>} // if aggregate </java>	

<java>if (collection.hasCalculator()) { </java>

	/**
	 * @ejb:interface-method
	 */
	public java.util.Collection get<expr>collectionName</expr>() {		
		try {
			<java>
			MetaCalculator calculator = collection.getMetaCalculator();
			String calculatorClass = calculator.getClassName();
			</java> 		
			<expr>calculatorClass</expr> <expr>collection.getName()</expr>Calculator= (<expr>calculatorClass</expr>)
				getMetaModel().getMetaCollection("<expr>collection.getName()</expr>").getMetaCalculator().getCalculator();
			<java>	
			Iterator itSets = calculator.getMetaSetsWithoutValue().iterator();
			while (itSets.hasNext()) {
				MetaSet set = (MetaSet) itSets.next();
				String propertyNameInCalculator = Strings.firstUpper(set.getPropertyName());
				String propertyNameFrom = set.getPropertyNameFrom();
				MetaProperty p = metaModel.getMetaProperty(propertyNameFrom);				
				if (propertyNameFrom.indexOf('.') &gt;= 0) {
					if (p.isKey() || p.getMetaModel() instanceof MetaAggregate) {
						propertyNameFrom = Strings.firstUpper(Strings.change(propertyNameFrom, ".", "_"));
					}
					else {
						StringTokenizer st = new StringTokenizer(propertyNameFrom, ".");
						String ref = st.nextToken();
						String pro = st.nextToken();
						propertyNameFrom = Strings.firstUpper(ref) + "().get" + Strings.firstUpper(pro);
					}
				}
				else {
					propertyNameFrom = Strings.firstUpper(propertyNameFrom);
				}
				String getPropertyFrom = "boolean".equals(p.getTypeName())?"is":"get";
				String value = set.getValue();
				if (set.hasValue()) {
			</java> 
			<expr>collection.getName()</expr>Calculator.set<expr>propertyNameInCalculator</expr>("<expr>value</expr>");
			<java>
				} else {	
			</java>  	
			<expr>collection.getName()</expr>Calculator.set<expr>propertyNameInCalculator</expr>(<expr>getPropertyFrom</expr><expr>propertyNameFrom</expr>());
			<java>	}} // else/sets 	 
			if (IEntityCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
			</java> 
				<expr>collection.getName()</expr>Calculator.setEntity(this);
			<java>} 
			if (IJDBCCalculator.class.isAssignableFrom(Class.forName(calculatorClass))) { 
			</java> 
				<expr>collection.getName()</expr>Calculator.setConnectionProvider(getPortableContext());			
			<java>			
			}  
			String calculateValueSentence = collection.getName() + "Calculator.calculate()";		
			</java> 
			return <expr>Generators.generateCast("java.util.Collection", calculateValueSentence)</expr>;
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("generator.calculate_value_error", "<expr>collection.getName()</expr>", "<expr>metaModel.getName()</expr>", ex.getLocalizedMessage()));
		}
	}

<java>} else { </java> 

	/**
	 * @ejb:interface-method
	 */
	public java.util.Collection get<expr>collectionName</expr>() {		
		try {
			return <expr>getHome</expr>().find<expr>finderName</expr>(<expr>finderArguments</expr>);
		}
		catch (Exception ex) {
			ex.printStackTrace();
			throw new EJBException(XavaResources.getString("get_collection_elements_error", "<expr>collectionName</expr>", "<expr>name</expr>"));
		}
	}
		
	private <expr>homeClass</expr> <expr>getHome</expr>() throws Exception{
		if (<expr>homeAttribute</expr> == null) {
			<expr>homeAttribute</expr> = (<expr>homeClass</expr>) PortableRemoteObject.narrow(
			 		BeansContext.get().lookup("<expr>referencedJNDI</expr>"),
			 		<expr>homeClass</expr>.class);			 		
		}
		return <expr>homeAttribute</expr>;
	}

<java>} // collection.hasCalculator </java>
	
<java>} // collections </java>		

	// References/Referencias
	
  
<java>
Iterator itReferences = metaModel.getMetaReferences().iterator();	
while (itReferences.hasNext()) {	
	MetaReference reference = (MetaReference) itReferences.next();
	String referenceName = Strings.firstUpper(reference.getName());	
	if (reference.getMetaModelReferenced() instanceof MetaAggregateBean) {	
		AggregateReferencePG.generateEJB(context, out, reference);
	} 
	else { // reference to entity or aggreate implemented as EJB
		EntityReferenceEJBPG.generate(context, out, reference);
	}
} 
</java> 
 
<java>	
	MethodsPG.generateEJB(context, out, metaModel); 
</java> 

	private MetaModel metaModel;
	private MetaModel getMetaModel() throws XavaException {
		if (metaModel == null) {
		<java>if (aggregateName == null) { </java>
			metaModel = MetaComponent.get("<expr>componentName</expr>").getMetaEntity();
		<java>} else { </java> 
			metaModel = MetaComponent.get("<expr>componentName</expr>").getMetaAggregate("<expr>aggregateName</expr>");
		<java>} </java> 	
		}
		return metaModel;
	}
	
	
	/**
	 * @ejb:interface-method
	 */	
	public abstract <expr>packageName</expr>.<expr>name</expr>Data getData();		
	
	/**
	 * @ejb:interface-method
	 */		
	public abstract void setData(<expr>packageName</expr>.<expr>name</expr>Data data);
	
	/**
	 * @ejb:interface-method
	 */	
	public abstract <expr>packageName</expr>.<expr>name</expr>Value get<expr>name</expr>Value();		
	
	/**
	 * @ejb:interface-method
	 */		
	public abstract void set<expr>name</expr>Value(<expr>packageName</expr>.<expr>name</expr>Value value);
	
	public void setEntityContext(javax.ejb.EntityContext ctx) {
		super.setEntityContext(ctx);
	}
	public void unsetEntityContext() {
		super.unsetEntityContext();
	}
	
	private void initMembers() {
		<java>
		Iterator itPropertiesToInit = metaModel.getMetaPropertiesPersistents().iterator();
		while (itPropertiesToInit.hasNext()) {
			MetaProperty p = (MetaProperty) itPropertiesToInit.next();
			String propertyName = Strings.firstUpper(p.getName());
			if (!p.getType().isPrimitive()) {				
		</java> 
		set<expr>propertyName</expr>(null);
		<java>
			}
			else if (p.isNumber()) {
		</java> 
		set<expr>propertyName</expr>(0);
		<java>	
			}
			else if (p.getType().getName().equals("boolean")) {
		</java> 
		set<expr>propertyName</expr>(false);
		<java>
			}
		}
		</java> 
		
		<java>
		for (Iterator it = metaModel.getMetaReferencesWithMapping().iterator(); it.hasNext(); ) {
			MetaReference ref = (MetaReference) it.next();
			String refName = Strings.firstUpper(ref.getName());
		</java> 
		set<expr>refName</expr>Key(null);
		<java>
		}
		</java> 	
	}
		
}
</tl>