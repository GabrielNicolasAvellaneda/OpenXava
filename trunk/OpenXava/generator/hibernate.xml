<?xml version="1.0"?>
<tl>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
<declare import="org.openxava.component.MetaComponent"/>
<declare import="org.openxava.model.meta.*"/>
<declare import="org.openxava.mapping.*"/>
<declare import="org.openxava.util.Strings"/>

&lt;!-- Generated by OpenXava: <expr>new Date()</expr> --&gt;
<java>
String packageName = properties.getProperty("arg3");
String componentName = properties.getProperty("arg4");
String aggregateName = properties.getProperty("arg5");
MetaComponent component = MetaComponent.get(componentName);

String name=null;
IMetaModel metaModel=null;
if (aggregateName == null) {
	name=componentName;	
	metaModel = (IMetaModel) component.getMetaEntity();
}
else {
	name=aggregateName;	
	metaModel =  (IMetaEjb)component.getMetaAggregate(aggregateName);
}
ModelMapping mapping = metaModel.getMapping();
</java>

&lt;!DOCTYPE hibernate-mapping SYSTEM "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="<expr>packageName</expr>"&gt;

  &lt;class 
  	name="<expr>name</expr>"
  	table="<expr>mapping.getTable()</expr>"&gt;
  	
<java>
Collection keyProperties = metaModel.getMetaPropertiesKey(); 
if (keyProperties.size() == 1) {
	MetaProperty key = (MetaProperty) keyProperties.iterator().next();
	PropertyMapping pMapping = key.getMapping();
	String propertyName = pMapping.hasConverter()?"_"+Strings.firstUpper(key.getName()):key.getName();	
</java> 	
		&lt;id name="<expr>propertyName</expr>" column="<expr>pMapping.getColumn()</expr>"&gt;
			&lt;generator class="assigned"/&gt;
		&lt;/id&gt;
<java>
}
else {
</java> 
		&lt;composite-id&gt;
<java>
	for (Iterator it = keyProperties.iterator(); it.hasNext();) {
		MetaProperty key = (MetaProperty) it.next();
		PropertyMapping pMapping = key.getMapping();
		String propertyName = pMapping.hasConverter()?"_"+Strings.firstUpper(key.getName()):key.getName();			
</java> 	
			&lt;key-property name="<expr>propertyName</expr>" column="<expr>pMapping.getColumn()</expr>"/&gt;
<java>	
	}
</java>  	
		&lt;/composite-id&gt;
<java>		
}

	Collection properties = metaModel.getMetaPropertiesPersistents();
	for (Iterator it = properties.iterator(); it.hasNext();) {
		MetaProperty prop = (MetaProperty) it.next();
		PropertyMapping pMapping = prop.getMapping();
		String propertyName = pMapping.hasConverter()?"_"+Strings.firstUpper(prop.getName()):prop.getName();			
		if (!prop.isKey()) {
</java> 	
		&lt;property name="<expr>propertyName</expr>" column="<expr>pMapping.getColumn()</expr>"/&gt;
<java>	
		} 
	}
</java>
   
<java>
Iterator itReferences = metaModel.getMetaReferences().iterator();	
while (itReferences.hasNext()) {	
	MetaReference reference = (MetaReference) itReferences.next();
	String referenceName = Strings.firstUpper(reference.getName());	
	if (reference.getMetaModelReferenced() instanceof MetaAggregateBean) {	
		for (Iterator itAggregateProperties = reference.getMetaModelReferenced().getMetaProperties().iterator(); itAggregateProperties.hasNext();) {	
			MetaProperty property = (MetaProperty) itAggregateProperties.next();
			String propertyName = "_" + referenceName + "_" + property.getName();
			String column = mapping.getColumn(reference.getName() + "_" + property.getName()); 
</java> 
		&lt;property name="<expr>propertyName</expr>" column="<expr>column</expr>"/&gt;
<java>           
		} 
		for (Iterator itAggregateReferences = reference.getMetaModelReferenced().getMetaReferences().iterator(); itAggregateReferences.hasNext();) {	
			MetaReference ref = (MetaReference) itAggregateReferences.next();
			String refName = reference.getName() + "_" + ref.getName();
			Collection columns = mapping.getReferenceMapping(reference.getName() + "_" + ref.getName()).getColumns();   
  			if (columns.size() == 1) {	
				String column = (String) columns.iterator().next();
</java> 
		&lt;many-to-one name="<expr>refName</expr>" column="<expr>column</expr>" class="<expr>ref.getMetaModelReferenced().getPOJOClassName()</expr>"/&gt;
<java>
			}
			else { 
</java> 
		&lt;!--  Mapping of "<expr>reference.getName() + "_" + ref.getName()</expr>": multiple key still not supported --&gt;
<java>
			}         
		}
	} 
	else { // reference to entity or aggreate implemented as EJB
		Collection columns = mapping.getReferenceMapping(reference.getName()).getColumns();   
  		if (columns.size() == 1) {	
			String column = (String) columns.iterator().next();
</java> 
		&lt;many-to-one name="<expr>reference.getName()</expr>" column="<expr>column</expr>" class="<expr>reference.getMetaModelReferenced().getPOJOClassName()</expr>"/&gt;
<java>
		}
		else { 
</java> 
		&lt;!--  Mapping of "<expr>reference.getName()</expr>": multiple key still not supported --&gt;
<java>
		}
	}
} 
 
Iterator itCollections = metaModel.getMetaCollections().iterator();	
while (itCollections.hasNext()) {	
	MetaCollection col = (MetaCollection) itCollections.next();
	boolean isAggregate = col.getMetaReference().getMetaModelReferenced() instanceof MetaAggregate;
	if (isAggregate || col.hasCalculator() || col.hasCondition()) {
		continue;
	}
	String roleName = col.getMetaReference().getRole();	 
	Collection columns = col.getMetaReference().getMetaModelReferenced().getMapping().getReferenceMapping(roleName).getColumns();
	if (columns.size() == 1) {	
		String column = (String) columns.iterator().next();
		Collection cKeys = col.getMetaReference().getMetaModelReferenced().getAllKeyPropertiesNames();
		String nKeys = Strings.toString(cKeys);          		
</java> 
		&lt;set name="<expr>col.getName()</expr>" order-by="<expr>nKeys</expr>"&gt;
			&lt;key column="<expr>column</expr>"/&gt;
			&lt;one-to-many class="<expr>col.getMetaReference().getMetaModelReferenced().getName()</expr>"/&gt;
		&lt;/set&gt;	
<java>
	}	
	else { 
</java> 
		&lt;!--  Mapping of "<expr>col.getName()</expr>": multiple key still not supported --&gt;
<java>
	}

}

</java> 	
  &lt;/class&gt;

&lt;/hibernate-mapping&gt;

</tl>