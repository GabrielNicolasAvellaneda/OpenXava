<?xml version="1.0"?>
<tl>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
<declare import="org.openxava.component.MetaComponent"/>
<declare import="org.openxava.model.meta.*"/>
<declare import="org.openxava.mapping.*"/>
<declare import="org.openxava.util.Strings"/>
<declare import="org.openxava.util.XavaException"/>

&lt;!-- Generated by OpenXava: <expr>new Date()</expr> --&gt;
<java>
String packageName = properties.getProperty("arg3");
String componentName = properties.getProperty("arg4");
String aggregateName = properties.getProperty("arg5");
MetaComponent component = MetaComponent.get(componentName);

String name=null;
IMetaModel metaModel=null;
if (aggregateName == null) {
	name=componentName;	
	metaModel = (IMetaModel) component.getMetaEntity();
}
else {
	name=aggregateName;	
	metaModel =  (IMetaEjb)component.getMetaAggregate(aggregateName);
}
ModelMapping mapping = metaModel.getMapping();
</java>

&lt;!DOCTYPE hibernate-mapping SYSTEM "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="<expr>packageName</expr>"&gt;

  &lt;class 
  	name="<expr>name</expr>"
  	table="<expr>mapping.getTable()</expr>"&gt;
  	
<java>
Collection keyMembers = metaModel.getMetaMembersKey();
Collection keyProperties = metaModel.getMetaPropertiesKey(); 
if (keyMembers.size() == 0) {
	throw new XavaException("model_without_key_error", name);
}
else if (keyProperties.size() == 1 &amp;&amp;  keyMembers.size() == 1) {
		MetaProperty key = (MetaProperty) keyProperties.iterator().next();
		PropertyMapping pMapping = key.getMapping();
		String propertyName = key.getName();	
		String generator = key.isHidden() &amp;&amp; !key.hasCalculatorDefaultValueOnCreate()?"native":"assigned";
		String type = pMapping.getCmpType().isArray()?"":"type='" + pMapping.getCmpTypeName() + "'";
</java> 	
		&lt;id name="<expr>propertyName</expr>" column="<expr>pMapping.getColumn()</expr>" access="field" <expr>type</expr>&gt;
			&lt;generator class="<expr>generator</expr>"/&gt;
		&lt;/id&gt;
<java>
}
else {
</java> 
		&lt;composite-id&gt;
<java>
	for (Iterator it = keyMembers.iterator(); it.hasNext();) {
    	MetaMember key = (MetaMember) it.next();
    	if (key instanceof MetaProperty) {
			PropertyMapping pMapping = ((MetaProperty) key).getMapping();
			String propertyName = key.getName();			
			String type = pMapping.getCmpType().isArray()?"":"type='" + pMapping.getCmpTypeName() + "'";			
</java> 	
			&lt;key-property name="<expr>propertyName</expr>" column="<expr>pMapping.getColumn()</expr>" access="field" <expr>type</expr>/&gt;
<java>
		}
		if (key instanceof MetaReference) {
			if (mapping.isReferenceOverlappingWithSomeProperty(key.getName())) {
</java> 
			&lt;!-- Reference: <expr>key.getName()</expr> Overlapped references still not supported --&gt;
<java>			
			}
			else {
				ReferenceMapping pMapping = mapping.getReferenceMapping(key.getName());
				String referenceName = key.getName();	
				String className = ((MetaReference) key).getMetaModelReferenced().getPOJOClassName();		
</java> 	
			&lt;key-many-to-one name="<expr>referenceName</expr>" class="<expr>className</expr>"&gt; 
<java>
				for (Iterator itC = pMapping.getColumns().iterator(); itC.hasNext();) {
					String col = (String) itC.next();				
</java> 			
				&lt;column name="<expr>col</expr>"/&gt;
<java>
				}			
</java> 						
			&lt;/key-many-to-one&gt;
<java>	
			}
 		} 		
 	}	
</java>  	
		&lt;/composite-id&gt;
<java>		
}
	Collection properties = metaModel.getMetaPropertiesPersistents();
	for (Iterator it = properties.iterator(); it.hasNext();) {
		MetaProperty prop = (MetaProperty) it.next();
		PropertyMapping pMapping = prop.getMapping();
		String propertyName = prop.getName();			
		if (!prop.isKey()) {
			if (pMapping.hasMultipleConverter()) {
</java> 
		&lt;!--  Mapping of "<expr>propertyName</expr>" : multiple columns mapping still not supported --&gt;
<java>			
			}
			else {
				String type = pMapping.getCmpType().isArray()?"":"type='" + pMapping.getCmpTypeName() + "'";
</java> 	
		&lt;property name="<expr>propertyName</expr>" column="<expr>pMapping.getColumn()</expr>" access="field" <expr>type</expr>/&gt;
<java>
			} 	
		} 
	}
 
Iterator itReferences = metaModel.getMetaReferences().iterator();	
while (itReferences.hasNext()) {	
	MetaReference reference = (MetaReference) itReferences.next();
	if (reference.isKey()) continue;
	String referenceName = Strings.firstUpper(reference.getName());	
	if (reference.getMetaModelReferenced() instanceof MetaAggregateBean) {	
		for (Iterator itAggregateProperties = reference.getMetaModelReferenced().getMetaPropertiesPersistents().iterator(); itAggregateProperties.hasNext();) {	
			MetaProperty property = (MetaProperty) itAggregateProperties.next();
			String propertyName = "_" + referenceName + "_" + property.getName();
			String column = mapping.getColumn(reference.getName() + "_" + property.getName()); 
			String type = property.getMapping().getCmpType().isArray()?"":"type='" + property.getMapping().getCmpTypeName() + "'";			
</java> 
		&lt;property name="<expr>propertyName</expr>" column="<expr>column</expr>" access="field" <expr>type</expr>/&gt;
<java>
		} 
		for (Iterator itAggregateReferences = reference.getMetaModelReferenced().getMetaReferences().iterator(); itAggregateReferences.hasNext();) {	
			MetaReference ref = (MetaReference) itAggregateReferences.next();
			String refName = reference.getName() + "_" + ref.getName();
			Collection columns = mapping.getReferenceMapping(reference.getName() + "_" + ref.getName()).getColumns();   
  			if (columns.size() == 1) {	
				String column = (String) columns.iterator().next();
</java> 
		&lt;many-to-one name="<expr>refName</expr>" column="<expr>column</expr>" class="<expr>ref.getMetaModelReferenced().getPOJOClassName()</expr>"/&gt;
<java>
			}
			else { 
</java> 
		&lt;many-to-one name="<expr>refName</expr>" class="<expr>ref.getMetaModelReferenced().getPOJOClassName()</expr>"&gt; 
<java>
			for (Iterator itC = columns.iterator(); itC.hasNext();) {
				String col = (String) itC.next();
</java> 
			&lt;column name="<expr>col</expr>" /&gt;
<java>
			}
</java> 
		&lt;/many-to-one&gt;
<java>
			}         
		}
	} 
	else { // reference to entity or persistent aggregate 
		Collection columns = mapping.getReferenceMapping(reference.getName()).getColumns();   
  		if (columns.size() == 1) {	
			String column = (String) columns.iterator().next();
</java> 
		&lt;many-to-one name="<expr>reference.getName()</expr>" column="<expr>column</expr>" class="<expr>reference.getMetaModelReferenced().getPOJOClassName()</expr>"/&gt;
<java>
		}
		else { 
			if (mapping.isReferenceOverlappingWithSomeProperty(reference.getName())) {
</java> 			
			&lt;!-- Reference: <expr>reference.getName()</expr> Overlapped references still not supported --&gt;
<java>
			}
			else {
</java> 
		&lt;many-to-one name="<expr>reference.getName()</expr>" class="<expr>reference.getMetaModelReferenced().getPOJOClassName()</expr>"&gt; 
<java>
			for (Iterator itC = columns.iterator(); itC.hasNext();) {
				String col = (String) itC.next();
</java> 
			&lt;column name="<expr>col</expr>"/&gt;
<java>			
			}
</java> 
		&lt;/many-to-one&gt;
<java>
			}
		}
	}
} 
 
Iterator itCollections = metaModel.getMetaCollections().iterator();	
while (itCollections.hasNext()) {	
	MetaCollection col = (MetaCollection) itCollections.next();
	if (col.hasCalculator() || col.hasCondition()) {
		continue;
	}
	boolean isAggregate = col.getMetaReference().getMetaModelReferenced() instanceof MetaAggregate;
	String cascadeDelete = isAggregate?"cascade='delete'":"";
	String roleName = col.getMetaReference().getRole();	 
	Collection columns = col.getMetaReference().getMetaModelReferenced().getMapping().getReferenceMapping(roleName).getColumns();
	Collection cKeys = col.getMetaReference().getMetaModelReferenced().getAllKeyPropertiesNames();
	String nKeys = Strings.toString(cKeys);          		
	if (columns.size() == 1) {	
		String column = (String) columns.iterator().next();
</java>  
		&lt;set name="<expr>col.getName()</expr>" order-by="<expr>nKeys</expr>" <expr>cascadeDelete</expr>&gt;
			&lt;key column="<expr>column</expr>"/&gt;
			&lt;one-to-many class="<expr>col.getMetaReference().getMetaModelReferenced().getName()</expr>"/&gt;
		&lt;/set&gt;	
<java>
	}	
	else { 
</java> 
		&lt;set name="<expr>col.getName()</expr>" order-by="<expr>nKeys</expr>" <expr>cascadeDelete</expr>&gt;
			&lt;key&gt;
<java>
		Iterator itCol = columns.iterator();	
		while (itCol.hasNext()) {	
			String column = (String) itCol.next();
</java> 			
				&lt;column name="<expr>column</expr>"/&gt;
<java>			
		}	
</java> 
			&lt;/key&gt;	
			&lt;one-to-many class="<expr>col.getMetaReference().getMetaModelReferenced().getName()</expr>"/&gt;
		&lt;/set&gt;	
<java>
	}

}

</java> 	
  &lt;/class&gt;

&lt;/hibernate-mapping&gt;

</tl>